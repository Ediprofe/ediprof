---
import MapVisualizer from "./MapVisualizer.astro";

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<div class="concept-map-wrapper" data-title={title}>
    <div class="concept-map-container">
        <!-- Botón de Descarga -->
        <button
            class="download-map-btn"
            title="Descargar como Imagen"
            aria-label="Descargar mapa conceptual"
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                ><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                ></path><polyline points="7 10 12 15 17 10"></polyline><line
                    x1="12"
                    y1="15"
                    x2="12"
                    y2="3"></line></svg
            >
            <span>Descargar</span>
        </button>

        <div class="map-root">
            <div class="root-label">{title}</div>
            <div class="root-v-line">║</div>
        </div>
        <div class="map-branches">
            <slot />
        </div>
    </div>

    <!-- Visor de Ilustraciones Global -->
    <MapVisualizer />
</div>

<script>
    import { toPng } from "html-to-image";

    // --- LÓGICA DEL PUNTERO LÁSER & LÁPIZ (PRECISIÓN ZOOM-AWARE) ---
    interface LaserPoint {
        x: number;
        y: number;
    }
    interface LaserStroke {
        points: LaserPoint[];
        isDead: boolean;
        isPermanent?: boolean;
        color: string;
    }

    class LaserPointer {
        private canvas: HTMLCanvasElement;
        public ctx: CanvasRenderingContext2D;
        private strokes: LaserStroke[] = [];
        private currentStroke: LaserStroke | null = null;
        public active = false;
        private toolMode: "laser" | "pen" = "laser";
        private currentColor: string = "#FFFFFF";
        private rafId: number | null = null;
        private lastGlobalActivityTime: number = Date.now();
        private duration = 3000;

        constructor(canvasId: string) {
            this.canvas = document.getElementById(
                canvasId,
            ) as HTMLCanvasElement;
            this.ctx = this.canvas.getContext("2d", { alpha: true })!;
            this.init();
        }

        private init() {
            window.addEventListener("resize", () => this.resize());
            this.resize();

            const getPos = (e: any) => {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x:
                        ((e.clientX || e.touches?.[0]?.clientX) - rect.left) *
                        scaleX,
                    y:
                        ((e.clientY || e.touches?.[0]?.clientY) - rect.top) *
                        scaleY,
                };
            };

            const start = (e: any) => {
                if (!this.active) return;
                if (e.touches) e.preventDefault();
                const { x, y } = getPos(e);
                this.lastGlobalActivityTime = Date.now();
                this.currentStroke = {
                    points: [{ x, y }],
                    isDead: false,
                    isPermanent: this.toolMode === "pen",
                    color:
                        this.toolMode === "laser"
                            ? "#FF0000"
                            : this.currentColor,
                };
                this.strokes.push(this.currentStroke);
            };

            const move = (e: any) => {
                if (!this.active || !this.currentStroke) return;
                const { x, y } = getPos(e);
                this.lastGlobalActivityTime = Date.now();
                this.currentStroke.points.push({ x, y });
                if (this.currentStroke.points.length > 800)
                    this.currentStroke.points.shift();
            };

            const stop = () => {
                this.currentStroke = null;
                this.lastGlobalActivityTime = Date.now();
            };

            this.canvas.addEventListener("mousedown", start, {
                passive: false,
            });
            window.addEventListener("mousemove", move, { passive: false });
            window.addEventListener("mouseup", stop);

            this.canvas.addEventListener("touchstart", start, {
                passive: false,
            });
            window.addEventListener("touchmove", move, { passive: false });
            window.addEventListener("touchend", stop);
        }

        public resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        public toggleSystem(state: boolean) {
            this.active = state;
            this.canvas.classList.toggle("active", state);
            if (state) {
                this.startLoop();
            } else {
                this.clearAll();
            }
        }

        public setMode(mode: "laser" | "pen") {
            this.toolMode = mode;
        }
        public setColor(color: string) {
            this.currentColor = color;
        }
        public undo() {
            this.strokes.pop();
            this.lastGlobalActivityTime = Date.now();
        }

        public clearAll() {
            this.strokes = [];
            this.lastGlobalActivityTime = 0;
            this.clearCanvas();
        }

        private startLoop() {
            if (this.rafId) return;
            const loop = () => {
                this.update();
                this.draw();
                this.rafId = requestAnimationFrame(loop);
            };
            this.rafId = requestAnimationFrame(loop);
        }

        private update() {
            const now = Date.now();
            const timeSinceLastActivity = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            if (timeSinceLastActivity > this.duration) {
                this.strokes = this.strokes.filter((s) => s.isPermanent);
            }
        }

        public clearCanvas() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        private draw() {
            this.clearCanvas();
            if (this.strokes.length === 0) return;

            const now = Date.now();
            const idleTime = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            const globalAlpha = Math.max(0, 1 - idleTime / this.duration);

            this.strokes.forEach((stroke) => {
                if (stroke.points.length < 2) return;
                const alpha = stroke.isPermanent ? 1.0 : globalAlpha;
                if (alpha <= 0) return;

                if (stroke.isPermanent) {
                    const rgb = this.hexToRgb(stroke.color);
                    this.renderStroke(
                        stroke,
                        `rgba(${rgb}, ${alpha})`,
                        4,
                        3,
                        "source-over",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.4})`,
                        1.5,
                        0,
                        "source-over",
                    );
                } else {
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.3})`,
                        25,
                        30,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.8})`,
                        8,
                        10,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.95})`,
                        3,
                        0,
                        "source-over",
                    );
                }
            });
        }

        private hexToRgb(hex: string): string {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }

        private renderStroke(
            stroke: LaserStroke,
            color: string,
            width: number,
            blur: number,
            composite: string,
        ) {
            this.ctx.globalCompositeOperation = composite as any;
            this.ctx.beginPath();
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = width;
            this.ctx.lineCap = "round";
            this.ctx.lineJoin = "round";
            this.ctx.shadowBlur = blur;
            this.ctx.shadowColor = color;

            const pts = stroke.points;
            this.ctx.moveTo(pts[0].x, pts[0].y);

            for (let i = 1; i < pts.length - 1; i++) {
                const midX = (pts[i].x + pts[i + 1].x) / 2;
                const midY = (pts[i].y + pts[i + 1].y) / 2;
                this.ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
            }
            this.ctx.stroke();
        }
    }

    // --- SISTEMA DE MOVIMIENTO Y ZOOM TÁCTIL (MULTI-TOUCH) ---
    class PanZoomSystem {
        private container: HTMLElement;
        private dx = 0;
        private dy = 0; // Posición actual
        private startX = 0;
        private startY = 0; // Posición inicial toque
        private scale = 1;
        private initialPinchDistance = 0;
        private initialScale = 1;
        private isDragging = false;
        public active = true;

        constructor(containerId: string) {
            this.container = document.getElementById(containerId)!;
            this.init();
        }

        private init() {
            const start = (e: any) => {
                if (!this.active) return;

                if (e.touches && e.touches.length === 2) {
                    this.isDragging = false;
                    this.initialPinchDistance = this.getDistance(
                        e.touches[0],
                        e.touches[1],
                    );
                    this.initialScale = this.scale;
                    return;
                }

                this.isDragging = true;
                const pos = this.getPos(e);
                this.startX = pos.x - this.dx;
                this.startY = pos.y - this.dy;
            };

            const move = (e: any) => {
                if (!this.active) return;

                // Zoom (Pellizco)
                if (e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const dist = this.getDistance(e.touches[0], e.touches[1]);
                    const ratio = dist / this.initialPinchDistance;
                    this.scale = Math.min(
                        Math.max(this.initialScale * ratio, 1),
                        6,
                    );
                    this.apply();
                    return;
                }

                // Mover (Pan)
                if (!this.isDragging) return;
                e.preventDefault();
                const pos = this.getPos(e);
                this.dx = pos.x - this.startX;
                this.dy = pos.y - this.startY;
                this.apply();
            };

            const stop = () => {
                this.isDragging = false;
            };

            const wheelZoom = (e: WheelEvent) => {
                if (!this.active) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.scale = Math.min(Math.max(this.scale * delta, 1), 6);
                this.apply();
            };

            this.container.addEventListener("mousedown", start);
            window.addEventListener("mousemove", move);
            window.addEventListener("mouseup", stop);
            this.container.addEventListener("touchstart", start, {
                passive: false,
            });
            window.addEventListener("touchmove", move, { passive: false });
            window.addEventListener("touchend", stop);
            this.container.addEventListener("wheel", wheelZoom, {
                passive: false,
            });
        }

        private getDistance(t1: any, t2: any) {
            return Math.sqrt(
                Math.pow(t2.clientX - t1.clientX, 2) +
                    Math.pow(t2.clientY - t1.clientY, 2),
            );
        }

        private getPos(e: any) {
            return {
                x: e.clientX || e.touches?.[0]?.clientX,
                y: e.clientY || e.touches?.[0]?.clientY,
            };
        }

        private apply() {
            this.container.style.transform = `translate(${this.dx}px, ${this.dy}px) scale(${this.scale})`;
        }

        public reset() {
            this.dx = 0;
            this.dy = 0;
            this.scale = 1;
            this.apply();
        }

        public setEnabled(state: boolean) {
            this.active = state;
            this.container.classList.toggle("draggable", state);
        }
    }

    function initMapSystem() {
        const wrappers = document.querySelectorAll(".concept-map-wrapper");
        const overlay = document.getElementById("map-visualizer-overlay");

        if (overlay && overlay.parentElement !== document.body) {
            document.body.appendChild(overlay);
        }

        const visualizerImg = document.getElementById(
            "visualizer-img",
        ) as HTMLImageElement;
        const closeBtn = document.getElementById("close-visualizer");
        const prevBtn = document.getElementById(
            "prev-img-side",
        ) as HTMLButtonElement;
        const nextBtn = document.getElementById(
            "next-img-side",
        ) as HTMLButtonElement;
        const counter = document.getElementById("visualizer-counter");

        const handBtn = document.getElementById("hand-btn");
        const laserBtn = document.getElementById("laser-btn");
        const penBtn = document.getElementById("pen-btn");
        const clearBtn = document.getElementById("clear-btn");
        const undoBtn = document.getElementById("undo-btn");
        const colorDots = document.querySelectorAll(".color-dot");

        const laserPointer = new LaserPointer("laser-canvas");
        const panZoom = new PanZoomSystem("pan-zoom-wrapper");

        let visualizerToolsActive = false;

        const setTool = (tool: "hand" | "laser" | "pen") => {
            panZoom.setEnabled(tool === "hand");
            laserPointer.setMode(tool === "hand" ? "laser" : (tool as any));
            laserPointer.active = tool !== "hand";

            handBtn?.classList.toggle("active", tool === "hand");
            laserBtn?.classList.toggle("active", tool === "laser");
            penBtn?.classList.toggle("active", tool === "pen");

            if (!visualizerToolsActive) {
                visualizerToolsActive = true;
                laserPointer.toggleSystem(true);
            }
        };

        const updateGallery = () => {
            if (visualizerImg && counter && prevBtn && nextBtn) {
                visualizerImg.src = currentImages[currentIndex];
                counter.textContent = `${currentIndex + 1} / ${currentImages.length}`;
                prevBtn.disabled = currentIndex === 0;
                nextBtn.disabled = currentIndex === currentImages.length - 1;
                panZoom.reset();
            }
        };

        const closeVisualizer = () => {
            overlay?.classList.remove("active");
            document.body.classList.remove("visualizer-open");
            visualizerToolsActive = false;
            laserPointer.toggleSystem(false);
            panZoom.reset();
        };

        let currentImages: string[] = [];
        let currentIndex = 0;

        const nextImage = () => {
            if (currentIndex < currentImages.length - 1) {
                currentIndex++;
                updateGallery();
            }
        };
        const prevImage = () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateGallery();
            }
        };

        wrappers.forEach((wrapper) => {
            wrapper.querySelectorAll(".view-images-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    const imagesData = btn.getAttribute("data-images");
                    if (imagesData && overlay) {
                        currentImages = JSON.parse(imagesData);
                        currentIndex = 0;
                        updateGallery();
                        overlay.classList.add("active");
                        document.body.classList.add("visualizer-open");
                        laserPointer.resize();
                        setTool("hand");
                    }
                });
            });
        });

        closeBtn?.addEventListener("click", closeVisualizer);
        handBtn?.addEventListener("click", () => setTool("hand"));
        laserBtn?.addEventListener("click", () => setTool("laser"));
        penBtn?.addEventListener("click", () => setTool("pen"));
        clearBtn?.addEventListener("click", () => laserPointer.clearAll());
        undoBtn?.addEventListener("click", () => laserPointer.undo());

        colorDots.forEach((dot) => {
            dot.addEventListener("click", () => {
                const color = dot.getAttribute("data-color") || "#FFFFFF";
                laserPointer.setColor(color);
                colorDots.forEach((d) => d.classList.remove("active"));
                dot.classList.add("active");
                setTool("pen");
            });
        });

        overlay?.addEventListener("click", (e) => {
            if (
                e.target === overlay ||
                (e.target as HTMLElement).classList.contains("image-stage")
            )
                closeVisualizer();
        });

        prevBtn?.addEventListener("click", prevImage);
        nextBtn?.addEventListener("click", nextImage);

        const handleKeyDown = (e: KeyboardEvent) => {
            if (!overlay?.classList.contains("active")) return;
            const key = e.key.toLowerCase();
            const isMod = e.ctrlKey || e.metaKey;

            if (isMod && key === "z") {
                e.preventDefault();
                laserPointer.undo();
            } else if (e.key === "Escape") closeVisualizer();
            else if (e.key === "ArrowRight") nextImage();
            else if (e.key === "ArrowLeft") prevImage();
            else if (key === "h") setTool("hand");
            else if (key === "l") setTool("laser");
            else if (key === "p") setTool("pen");
            else if (key === "c") laserPointer.clearAll();
        };

        window.removeEventListener("keydown", handleKeyDown);
        window.addEventListener("keydown", handleKeyDown);
    }

    initMapSystem();
    document.addEventListener("astro:page-load", initMapSystem);
</script>

<style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap");

    .concept-map-wrapper {
        position: relative;
        margin: 3rem 0;
    }
    .concept-map-container {
        background-color: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 16px;
        padding: 1.5rem 2rem;
        font-family: "Space Grotesk", sans-serif;
        color: #334155;
        position: relative;
        overflow: hidden;
    }
    .concept-map-container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 4px;
        height: 100%;
        background: #2563eb;
    }
    .download-map-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        color: #64748b;
        font-family: inherit;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10;
    }
    .download-map-btn:hover {
        background: #f1f5f9;
        color: #2563eb;
        border-color: #cbd5e1;
        transform: translateY(-1px);
    }
    .map-root {
        margin-bottom: 1rem;
    }
    .root-label {
        font-weight: 400;
        font-size: 1.3rem;
        color: #0f172a;
        letter-spacing: -0.02em;
    }
    .root-v-line {
        color: #cbd5e1;
        margin-left: 0.1rem;
        font-size: 0.9rem;
        margin-top: 0.2rem;
    }
    .map-branches {
        border-left: 1.5px solid #cbd5e1;
        margin-left: 0.5rem;
        padding-left: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
        padding-top: 0.5rem;
    }
</style>
