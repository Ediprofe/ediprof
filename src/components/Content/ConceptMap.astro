---
import MapVisualizer from "./MapVisualizer.astro";

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<div class="concept-map-wrapper" data-title={title}>
    <div class="concept-map-container">
        <!-- Botón de Descarga -->
        <button
            class="download-map-btn"
            title="Descargar como Imagen"
            aria-label="Descargar mapa conceptual"
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                ><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                ></path><polyline points="7 10 12 15 17 10"></polyline><line
                    x1="12"
                    y1="15"
                    x2="12"
                    y2="3"></line></svg
            >
            <span>Descargar</span>
        </button>

        <div class="map-root">
            <div class="root-label">{title}</div>
            <div class="root-v-line">║</div>
        </div>
        <div class="map-branches">
            <slot />
        </div>
    </div>

    <!-- Visor de Ilustraciones Global -->
    <MapVisualizer />
</div>

<script>
    import { toPng } from "html-to-image";

    // --- LÓGICA DEL PUNTERO LÁSER & LÁPIZ (SINCRONÍA DE LUZ) ---
    interface LaserPoint {
        x: number;
        y: number;
    }
    interface LaserStroke {
        points: LaserPoint[];
        isDead: boolean;
        isPermanent?: boolean;
        color: string;
    }

    class LaserPointer {
        private canvas: HTMLCanvasElement;
        public ctx: CanvasRenderingContext2D;
        private strokes: LaserStroke[] = [];
        private currentStroke: LaserStroke | null = null;
        public isInputActive = false;
        private systemRunning = false;
        private toolMode: "laser" | "pen" = "laser";
        private currentColor: string = "#FFFFFF";
        private rafId: number | null = null;
        private lastGlobalActivityTime: number = Date.now();
        private duration = 3000;
        private isBlockedByGesture = false;

        constructor(canvasId: string) {
            this.canvas = document.getElementById(
                canvasId,
            ) as HTMLCanvasElement;
            this.ctx = this.canvas.getContext("2d", { alpha: true })!;
            this.init();
        }

        private init() {
            window.addEventListener("resize", () => this.resize());
            this.resize();

            this.canvas.addEventListener(
                "mousedown",
                (e) => this.handleStart(e),
                {
                    passive: false,
                },
            );
            window.addEventListener("mousemove", (e) => this.handleMove(e), {
                passive: false,
            });
            window.addEventListener("mouseup", () => this.handleStop());
            this.canvas.addEventListener(
                "touchstart",
                (e) => this.handleStart(e),
                {
                    passive: false,
                },
            );
            window.addEventListener("touchmove", (e) => this.handleMove(e), {
                passive: false,
            });
            window.addEventListener("touchend", () => this.handleStop());
        }

        private getPos(e: MouseEvent | TouchEvent) {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const clientX = "clientX" in e ? e.clientX : e.touches[0].clientX;
            const clientY = "clientY" in e ? e.clientY : e.touches[0].clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY,
            };
        }

        private handleStart(e: MouseEvent | TouchEvent) {
            if (!this.isInputActive || this.isBlockedByGesture) return;
            if ("touches" in e && e.touches.length > 1) {
                this.isBlockedByGesture = true;
                this.handleStop();
                return;
            }

            if ("touches" in e) e.preventDefault();
            const { x, y } = this.getPos(e);
            this.lastGlobalActivityTime = Date.now();
            this.currentStroke = {
                points: [{ x, y }],
                isDead: false,
                isPermanent: this.toolMode === "pen",
                color:
                    this.toolMode === "laser" ? "#FF0000" : this.currentColor,
            };
            this.strokes.push(this.currentStroke);
        }

        private handleMove(e: MouseEvent | TouchEvent) {
            if (
                !this.isInputActive ||
                !this.currentStroke ||
                this.isBlockedByGesture
            )
                return;
            if ("touches" in e && e.touches.length > 1) {
                this.handleStop();
                return;
            }

            const { x, y } = this.getPos(e);
            this.lastGlobalActivityTime = Date.now();
            this.currentStroke.points.push({ x, y });
            if (this.currentStroke.points.length > 800)
                this.currentStroke.points.shift();
        }

        private handleStop() {
            this.currentStroke = null;
            this.lastGlobalActivityTime = Date.now();
        }

        public setGestureBlock(state: boolean) {
            this.isBlockedByGesture = state;
            if (state) this.currentStroke = null;
        }

        public resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        public startSystem() {
            if (this.systemRunning) return;
            this.systemRunning = true;
            this.startLoop();
        }

        public stopSystem() {
            this.systemRunning = false;
            this.isInputActive = false;
            this.clearAll();
            if (this.rafId) cancelAnimationFrame(this.rafId);
            this.rafId = null;
        }

        public setDrawingEnabled(enabled: boolean) {
            this.isInputActive = enabled;
            this.canvas.style.pointerEvents = enabled ? "auto" : "none";
        }

        public setMode(mode: "laser" | "pen") {
            this.toolMode = mode;
        }
        public setColor(color: string) {
            this.currentColor = color;
        }
        public undo() {
            this.strokes.pop();
            this.lastGlobalActivityTime = Date.now();
        }

        public clearAll() {
            this.strokes = [];
            this.lastGlobalActivityTime = 0;
            this.clearCanvas();
        }

        private startLoop() {
            const loop = () => {
                if (!this.systemRunning) return;
                this.update();
                this.draw();
                this.rafId = requestAnimationFrame(loop);
            };
            this.rafId = requestAnimationFrame(loop);
        }

        private update() {
            const now = Date.now();
            const timeSinceLastActivity = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            if (timeSinceLastActivity > this.duration) {
                this.strokes = this.strokes.filter((s) => s.isPermanent);
            }
        }

        public clearCanvas() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        private draw() {
            this.clearCanvas();
            if (this.strokes.length === 0) return;

            const now = Date.now();
            const idleTime = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            const globalAlpha = Math.max(0, 1 - idleTime / this.duration);

            this.strokes.forEach((stroke) => {
                if (stroke.points.length < 2) return;
                const alpha = stroke.isPermanent ? 1.0 : globalAlpha;
                if (alpha <= 0) return;

                if (stroke.isPermanent) {
                    const rgb = this.hexToRgb(stroke.color);
                    this.renderStroke(
                        stroke,
                        `rgba(${rgb}, ${alpha})`,
                        4,
                        3,
                        "source-over",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.4})`,
                        1.5,
                        0,
                        "source-over",
                    );
                } else {
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.3})`,
                        25,
                        30,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.8})`,
                        8,
                        10,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.95})`,
                        3,
                        0,
                        "source-over",
                    );
                }
            });
        }

        private hexToRgb(hex: string): string {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }

        private renderStroke(
            stroke: LaserStroke,
            color: string,
            width: number,
            blur: number,
            composite: string,
        ) {
            this.ctx.globalCompositeOperation = composite as any;
            this.ctx.beginPath();
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = width;
            this.ctx.lineCap = "round";
            this.ctx.lineJoin = "round";
            this.ctx.shadowBlur = blur;
            this.ctx.shadowColor = color;
            const pts = stroke.points;
            this.ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length - 1; i++) {
                const midX = (pts[i].x + pts[i + 1].x) / 2;
                const midY = (pts[i].y + pts[i + 1].y) / 2;
                this.ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
            }
            this.ctx.stroke();
        }
    }

    // --- SISTEMA DE MOVIMIENTO Y ZOOM TÁCTIL ---
    class PanZoomSystem {
        private container: HTMLElement;
        private dx = 0;
        private dy = 0;
        private startX = 0;
        private startY = 0;
        private scale = 1;
        private initialPinchDistance = 0;
        private initialScale = 1;
        private isDragging = false;
        private onGestureStateChange: (gesturing: boolean) => void;
        public active = true;

        constructor(
            containerId: string,
            onGestureStateChange: (gesturing: boolean) => void,
        ) {
            this.container = document.getElementById(containerId)!;
            this.onGestureStateChange = onGestureStateChange;
            this.init();
        }

        private init() {
            const start = (e: MouseEvent | TouchEvent) => {
                if ("touches" in e && e.touches.length >= 2) {
                    this.isDragging = false;
                    this.onGestureStateChange(true);
                    this.initialPinchDistance = this.getDistance(
                        e.touches[0],
                        e.touches[1],
                    );
                    this.initialScale = this.scale;
                    return;
                }

                if (!this.active) return;
                this.isDragging = true;
                const pos = this.getPos(e);
                this.startX = pos.x - this.dx;
                this.startY = pos.y - this.dy;
            };

            const move = (e: MouseEvent | TouchEvent) => {
                if ("touches" in e && e.touches.length >= 2) {
                    e.preventDefault();
                    const dist = this.getDistance(e.touches[0], e.touches[1]);
                    if (this.initialPinchDistance > 0) {
                        const ratio = dist / this.initialPinchDistance;
                        this.scale = Math.min(
                            Math.max(this.initialScale * ratio, 1),
                            6,
                        );
                        this.apply();
                    }
                    return;
                }

                if (this.isDragging && this.active) {
                    e.preventDefault();
                    const pos = this.getPos(e);
                    this.dx = pos.x - this.startX;
                    this.dy = pos.y - this.startY;
                    this.apply();
                }
            };

            const stop = () => {
                this.isDragging = false;
                setTimeout(() => this.onGestureStateChange(false), 150);
            };

            this.container.addEventListener("mousedown", start, {
                passive: false,
            });
            window.addEventListener("mousemove", move, { passive: false });
            window.addEventListener("mouseup", stop);
            this.container.addEventListener("touchstart", start, {
                passive: false,
            });
            window.addEventListener("touchmove", move, { passive: false });
            window.addEventListener("touchend", stop);
            this.container.addEventListener("touchcancel", stop);
            this.container.addEventListener(
                "wheel",
                (e) => {
                    if (!this.active && !e.ctrlKey) return;
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale = Math.min(Math.max(this.scale * delta, 1), 6);
                    this.apply();
                },
                { passive: false },
            );
        }

        private getDistance(t1: Touch, t2: Touch) {
            return Math.sqrt(
                Math.pow(t2.clientX - t1.clientX, 2) +
                    Math.pow(t2.clientY - t1.clientY, 2),
            );
        }

        private getPos(e: MouseEvent | TouchEvent) {
            const clientX = "clientX" in e ? e.clientX : e.touches[0].clientX;
            const clientY = "clientY" in e ? e.clientY : e.touches[0].clientY;
            return {
                x: clientX,
                y: clientY,
            };
        }

        private apply() {
            this.container.style.transform = `translate(${this.dx}px, ${this.dy}px) scale(${this.scale})`;
        }

        public reset() {
            this.dx = 0;
            this.dy = 0;
            this.scale = 1;
            this.apply();
        }

        public setEnabled(state: boolean) {
            this.active = state;
            this.container.classList.toggle("draggable", state);
        }
    }

    function initMapSystem() {
        const wrappers = document.querySelectorAll(".concept-map-wrapper");
        const overlay = document.getElementById("map-visualizer-overlay");
        if (overlay && overlay.parentElement !== document.body)
            document.body.appendChild(overlay);

        const visualizerImg = document.getElementById(
            "visualizer-img",
        ) as HTMLImageElement;
        const closeBtn = document.getElementById("close-visualizer");
        const prevBtn = document.getElementById(
            "prev-img-side",
        ) as HTMLButtonElement;
        const nextBtn = document.getElementById(
            "next-img-side",
        ) as HTMLButtonElement;

        const handBtn = document.getElementById("hand-btn");
        const laserBtn = document.getElementById("laser-btn");
        const penBtn = document.getElementById("pen-btn");
        const clearBtn = document.getElementById("clear-btn");
        const undoBtn = document.getElementById("undo-btn");
        const colorDots = document.querySelectorAll(".color-dot");

        const laserPointer = new LaserPointer("laser-canvas");
        const panZoom = new PanZoomSystem("pan-zoom-wrapper", (isGesturing) => {
            laserPointer.setGestureBlock(isGesturing);
        });

        let systemInitialized = false;

        const setTool = (tool: "hand" | "laser" | "pen") => {
            if (!systemInitialized) {
                laserPointer.startSystem();
                systemInitialized = true;
            }
            panZoom.setEnabled(tool === "hand");
            laserPointer.setDrawingEnabled(tool !== "hand");
            if (tool !== "hand") laserPointer.setMode(tool as "laser" | "pen");
            handBtn?.classList.toggle("active", tool === "hand");
            laserBtn?.classList.toggle("active", tool === "laser");
            penBtn?.classList.toggle("active", tool === "pen");
        };

        const updateGallery = () => {
            if (visualizerImg && prevBtn && nextBtn) {
                visualizerImg.src = currentImages[currentIndex];
                panZoom.reset();
            }
        };

        const closeVisualizer = () => {
            overlay?.classList.remove("active");
            document.body.classList.remove("visualizer-open");
            laserPointer.stopSystem();
            systemInitialized = false;
        };

        let currentImages: string[] = [];
        let currentIndex = 0;

        const nextImage = () => {
            if (currentIndex < currentImages.length - 1) {
                currentIndex++;
                updateGallery();
            }
        };
        const prevImage = () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateGallery();
            }
        };

        wrappers.forEach((wrapper) => {
            const title =
                wrapper.getAttribute("data-title") || "mapa-conceptual";
            const downloadBtn = wrapper.querySelector(".download-map-btn");
            wrapper.querySelectorAll(".view-images-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    const imagesData = btn.getAttribute("data-images");
                    if (imagesData && overlay) {
                        currentImages = JSON.parse(imagesData);
                        currentIndex = 0;
                        updateGallery();
                        overlay.classList.add("active");
                        document.body.classList.add("visualizer-open");
                        laserPointer.resize();
                        setTool("hand");
                    }
                });
            });

            if (downloadBtn) {
                downloadBtn.addEventListener("click", async () => {
                    const span = downloadBtn.querySelector("span");
                    const mapContainer = wrapper.querySelector(
                        ".concept-map-container",
                    ) as HTMLElement;
                    if (span) span.textContent = "Generando...";
                    try {
                        await new Promise((r) => setTimeout(r, 100));
                        const dataUrl = await toPng(mapContainer, {
                            backgroundColor: "#ffffff",
                            pixelRatio: 2,
                            filter: (node: HTMLElement) =>
                                !node.classList?.contains("download-map-btn") &&
                                !node.classList?.contains("view-images-btn"),
                        });
                        const link = document.createElement("a");
                        link.download = `Ediprofe-${title.replace(/\s+/g, "-")}.png`;
                        link.href = dataUrl;
                        link.click();
                    } finally {
                        if (span) span.textContent = "Descargar";
                    }
                });
            }
        });

        closeBtn?.addEventListener("click", closeVisualizer);
        handBtn?.addEventListener("click", () => setTool("hand"));
        laserBtn?.addEventListener("click", () => setTool("laser"));
        penBtn?.addEventListener("click", () => setTool("pen"));
        clearBtn?.addEventListener("click", () => laserPointer.clearAll());
        undoBtn?.addEventListener("click", () => laserPointer.undo());

        colorDots.forEach((dot) => {
            dot.addEventListener("click", () => {
                const color = dot.getAttribute("data-color") || "#FFFFFF";
                laserPointer.setColor(color);
                colorDots.forEach((d) => d.classList.remove("active"));
                dot.classList.add("active");
                setTool("pen");
            });
        });

        overlay?.addEventListener("click", (e) => {
            if (
                e.target === overlay ||
                (e.target as HTMLElement).classList.contains("image-stage")
            )
                closeVisualizer();
        });

        prevBtn?.addEventListener("click", prevImage);
        nextBtn?.addEventListener("click", nextImage);

        const handleKeyDown = (e: KeyboardEvent) => {
            if (!overlay?.classList.contains("active")) return;
            const key = e.key.toLowerCase();
            const isMod = e.ctrlKey || e.metaKey;
            if (isMod && key === "z") {
                e.preventDefault();
                laserPointer.undo();
            } else if (e.key === "Escape") closeVisualizer();
            else if (e.key === "ArrowRight") nextImage();
            else if (e.key === "ArrowLeft") prevImage();
            else if (key === "h") setTool("hand");
            else if (key === "l") setTool("laser");
            else if (key === "p") setTool("pen");
            else if (key === "c") laserPointer.clearAll();
        };

        window.removeEventListener("keydown", handleKeyDown);
        window.addEventListener("keydown", handleKeyDown);
    }

    initMapSystem();
    document.addEventListener("astro:page-load", initMapSystem);
</script>

<style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap");

    .concept-map-wrapper {
        position: relative;
        margin: 3rem 0;
    }

    .concept-map-container {
        background-color: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 16px;
        padding: 1.5rem 2rem;
        font-family: "Space Grotesk", sans-serif;
        color: #334155;
        position: relative;
        overflow: hidden;
    }

    .concept-map-container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 4px;
        height: 100%;
        background: #2563eb;
    }

    .download-map-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        color: #64748b;
        font-family: inherit;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10;
    }

    .download-map-btn:hover {
        background: #f1f5f9;
        color: #2563eb;
        border-color: #cbd5e1;
        transform: translateY(-1px);
    }

    .download-map-btn.loading {
        opacity: 0.7;
        pointer-events: none;
    }

    .map-root {
        margin-bottom: 1rem;
    }

    .root-label {
        font-weight: 400;
        font-size: 1.3rem;
        color: #0f172a;
        letter-spacing: -0.02em;
    }

    .root-v-line {
        color: #cbd5e1;
        margin-left: 0.1rem;
        font-size: 0.9rem;
        margin-top: 0.2rem;
    }

    .map-branches {
        border-left: 1.5px solid #cbd5e1;
        margin-left: 0.5rem;
        padding-left: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
        padding-top: 0.5rem;
    }
</style>
