---
import MapVisualizer from "./MapVisualizer.astro";

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<div class="concept-map-wrapper" data-title={title}>
    <div class="concept-map-container">
        <!-- Botón de Descarga -->
        <button
            class="download-map-btn"
            title="Descargar como Imagen"
            aria-label="Descargar mapa conceptual"
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                ><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                ></path><polyline points="7 10 12 15 17 10"></polyline><line
                    x1="12"
                    y1="15"
                    x2="12"
                    y2="3"></line></svg
            >
            <span>Descargar</span>
        </button>

        <div class="map-root">
            <div class="root-label">{title}</div>
            <div class="root-v-line">║</div>
        </div>
        <div class="map-branches">
            <slot />
        </div>
    </div>

    <!-- Visor de Ilustraciones Global -->
    <MapVisualizer />
</div>

<script>
    import { toPng } from "html-to-image";

    // --- LÓGICA DEL PUNTERO LÁSER & LÁPIZ (TIPO GOODNOTES - SINCRONÍA DE LUZ) ---
    interface LaserPoint {
        x: number;
        y: number;
    }
    interface LaserStroke {
        points: LaserPoint[];
        isDead: boolean;
        isPermanent?: boolean;
        color: string;
    }

    class LaserPointer {
        private canvas: HTMLCanvasElement;
        private ctx: CanvasRenderingContext2D;
        private strokes: LaserStroke[] = [];
        private currentStroke: LaserStroke | null = null;
        private active = false;
        private toolMode: "laser" | "pen" = "laser";
        private currentColor: string = "#FFFFFF";
        private rafId: number | null = null;
        private lastGlobalActivityTime: number = Date.now();
        private duration = 3000;

        constructor(canvasId: string) {
            this.canvas = document.getElementById(
                canvasId,
            ) as HTMLCanvasElement;
            this.ctx = this.canvas.getContext("2d", { alpha: true })!;
            this.init();
        }

        private init() {
            window.addEventListener("resize", () => this.resize());
            this.resize();

            const getPos = (e: any) => {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX || e.touches?.[0]?.clientX) - rect.left,
                    y: (e.clientY || e.touches?.[0]?.clientY) - rect.top,
                };
            };

            const start = (e: any) => {
                if (!this.active) return;
                if (e.touches) e.preventDefault();
                const { x, y } = getPos(e);
                this.lastGlobalActivityTime = Date.now();
                this.currentStroke = {
                    points: [{ x, y }],
                    isDead: false,
                    isPermanent: this.toolMode === "pen",
                    color:
                        this.toolMode === "laser"
                            ? "#FF0000"
                            : this.currentColor,
                };
                this.strokes.push(this.currentStroke);
            };

            const move = (e: any) => {
                if (!this.active || !this.currentStroke) return;
                const { x, y } = getPos(e);
                this.lastGlobalActivityTime = Date.now();
                this.currentStroke.points.push({ x, y });
                if (this.currentStroke.points.length > 500)
                    this.currentStroke.points.shift();
            };

            const stop = () => {
                this.currentStroke = null;
                this.lastGlobalActivityTime = Date.now();
            };

            this.canvas.addEventListener("mousedown", start);
            window.addEventListener("mousemove", move);
            window.addEventListener("mouseup", stop);

            this.canvas.addEventListener("touchstart", start, {
                passive: false,
            });
            window.addEventListener("touchmove", move, { passive: false });
            window.addEventListener("touchend", stop);
        }

        private resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        public toggleSystem(state: boolean) {
            this.active = state;
            this.canvas.classList.toggle("active", state);
            if (state) {
                this.startLoop();
            } else {
                this.clearAll();
            }
        }

        public setMode(mode: "laser" | "pen") {
            this.toolMode = mode;
        }

        public setColor(color: string) {
            this.currentColor = color;
        }

        public undo() {
            this.strokes.pop();
            this.lastGlobalActivityTime = Date.now();
        }

        public clearAll() {
            this.strokes = [];
            this.lastGlobalActivityTime = 0;
            this.clearCanvas();
        }

        private startLoop() {
            if (this.rafId) return;
            const loop = () => {
                this.update();
                this.draw();
                this.rafId = requestAnimationFrame(loop);
            };
            this.rafId = requestAnimationFrame(loop);
        }

        private update() {
            const now = Date.now();
            const timeSinceLastActivity = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            if (timeSinceLastActivity > this.duration) {
                this.strokes = this.strokes.filter((s) => s.isPermanent);
            }
        }

        private clearCanvas() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        private draw() {
            this.clearCanvas();
            if (this.strokes.length === 0) return;

            const now = Date.now();
            const idleTime = this.currentStroke
                ? 0
                : now - this.lastGlobalActivityTime;
            const globalAlpha = Math.max(0, 1 - idleTime / this.duration);

            this.strokes.forEach((stroke) => {
                if (stroke.points.length < 2) return;
                const alpha = stroke.isPermanent ? 1.0 : globalAlpha;
                if (alpha <= 0) return;

                if (stroke.isPermanent) {
                    // ESTILO LÁPIZ (Color dinámico)
                    const rgb = this.hexToRgb(stroke.color);
                    this.renderStroke(
                        stroke,
                        `rgba(${rgb}, ${alpha})`,
                        4,
                        3,
                        "source-over",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.4})`,
                        1.5,
                        0,
                        "source-over",
                    );
                } else {
                    // ESTILO LÁSER (Rojo Neón siempre)
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.3})`,
                        25,
                        30,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 0, 0, ${alpha * 0.8})`,
                        8,
                        10,
                        "lighter",
                    );
                    this.renderStroke(
                        stroke,
                        `rgba(255, 255, 255, ${alpha * 0.95})`,
                        3,
                        0,
                        "source-over",
                    );
                }
            });
        }

        private hexToRgb(hex: string): string {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }

        private renderStroke(
            stroke: LaserStroke,
            color: string,
            width: number,
            blur: number,
            composite: string,
        ) {
            this.ctx.globalCompositeOperation = composite as any;
            this.ctx.beginPath();
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = width;
            this.ctx.lineCap = "round";
            this.ctx.lineJoin = "round";
            this.ctx.shadowBlur = blur;
            this.ctx.shadowColor = color;

            const pts = stroke.points;
            this.ctx.moveTo(pts[0].x, pts[0].y);

            for (let i = 1; i < pts.length - 1; i++) {
                const midX = (pts[i].x + pts[i + 1].x) / 2;
                const midY = (pts[i].y + pts[i + 1].y) / 2;
                this.ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
            }
            this.ctx.stroke();
        }
    }

    function initMapSystem() {
        const wrappers = document.querySelectorAll(".concept-map-wrapper");
        const overlay = document.getElementById("map-visualizer-overlay");

        if (overlay && overlay.parentElement !== document.body) {
            document.body.appendChild(overlay);
        }

        const visualizerImg = document.getElementById(
            "visualizer-img",
        ) as HTMLImageElement;
        const closeBtn = document.getElementById("close-visualizer");
        const prevBtn = document.getElementById(
            "prev-img-side",
        ) as HTMLButtonElement;
        const nextBtn = document.getElementById(
            "next-img-side",
        ) as HTMLButtonElement;
        const counter = document.getElementById("visualizer-counter");

        // Elementos Láser & Lápiz
        const laserBtn = document.getElementById("laser-btn");
        const penBtn = document.getElementById("pen-btn");
        const clearBtn = document.getElementById("clear-btn");
        const undoBtn = document.getElementById("undo-btn");
        const colorDots = document.querySelectorAll(".color-dot");
        const laserPointer = new LaserPointer("laser-canvas");

        let visualizerToolsActive = false;
        let currentTool: "laser" | "pen" = "laser";

        const setTool = (tool: "laser" | "pen") => {
            currentTool = tool;
            laserPointer.setMode(tool);
            laserBtn?.classList.toggle("active", tool === "laser");
            penBtn?.classList.toggle("active", tool === "pen");

            if (!visualizerToolsActive) {
                visualizerToolsActive = true;
                laserPointer.toggleSystem(true);
            }
        };

        const updateGallery = () => {
            if (visualizerImg && counter && prevBtn && nextBtn) {
                visualizerImg.src = currentImages[currentIndex];
                counter.textContent = `${currentIndex + 1} / ${currentImages.length}`;
                prevBtn.disabled = currentIndex === 0;
                nextBtn.disabled = currentIndex === currentImages.length - 1;
            }
        };

        const closeVisualizer = () => {
            overlay?.classList.remove("active");
            document.body.classList.remove("visualizer-open");
            visualizerToolsActive = false;
            laserPointer.toggleSystem(false);
        };

        let currentImages: string[] = [];
        let currentIndex = 0;

        const nextImage = () => {
            if (currentIndex < currentImages.length - 1) {
                currentIndex++;
                updateGallery();
            }
        };

        const prevImage = () => {
            if (currentIndex > 0) {
                currentIndex--;
                updateGallery();
            }
        };

        wrappers.forEach((wrapper) => {
            const title =
                wrapper.getAttribute("data-title") || "mapa-conceptual";
            const downloadBtn = wrapper.querySelector(".download-map-btn");

            wrapper.querySelectorAll(".view-images-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    const imagesData = btn.getAttribute("data-images");
                    if (imagesData && overlay) {
                        currentImages = JSON.parse(imagesData);
                        currentIndex = 0;
                        updateGallery();
                        overlay.classList.add("active");
                        document.body.classList.add("visualizer-open");
                        setTool("laser");
                    }
                });
            });

            if (downloadBtn) {
                downloadBtn.addEventListener("click", async () => {
                    const span = downloadBtn.querySelector("span");
                    const mapContainer = wrapper.querySelector(
                        ".concept-map-container",
                    ) as HTMLElement;
                    if (span) span.textContent = "Generando...";
                    try {
                        await new Promise((r) => setTimeout(r, 100));
                        const dataUrl = await toPng(mapContainer, {
                            backgroundColor: "#ffffff",
                            pixelRatio: 2,
                            filter: (node: any) =>
                                !node.classList?.contains("download-map-btn") &&
                                !node.classList?.contains("view-images-btn"),
                        });
                        const link = document.createElement("a");
                        link.download = `Ediprofe-${title.replace(/\s+/g, "-")}.png`;
                        link.href = dataUrl;
                        link.click();
                    } finally {
                        if (span) span.textContent = "Descargar";
                    }
                });
            }
        });

        // Eventos Globales
        closeBtn?.addEventListener("click", closeVisualizer);
        laserBtn?.addEventListener("click", () => setTool("laser"));
        penBtn?.addEventListener("click", () => setTool("pen"));
        clearBtn?.addEventListener("click", () => laserPointer.clearAll());
        undoBtn?.addEventListener("click", () => laserPointer.undo());

        colorDots.forEach((dot) => {
            dot.addEventListener("click", () => {
                const color = dot.getAttribute("data-color") || "#FFFFFF";
                laserPointer.setColor(color);
                colorDots.forEach((d) => d.classList.remove("active"));
                dot.classList.add("active");
                setTool("pen"); // Activar lápiz automáticamente al elegir color
            });
        });

        overlay?.addEventListener("click", (e) => {
            if (
                e.target === overlay ||
                (e.target as HTMLElement).classList.contains("image-stage")
            )
                closeVisualizer();
        });

        prevBtn?.addEventListener("click", prevImage);
        nextBtn?.addEventListener("click", nextImage);

        const handleKeyDown = (e: KeyboardEvent) => {
            if (!overlay?.classList.contains("active")) return;
            const key = e.key.toLowerCase();
            const isMod = e.ctrlKey || e.metaKey;

            if (isMod && key === "z") {
                e.preventDefault();
                laserPointer.undo();
            } else if (e.key === "Escape") {
                closeVisualizer();
            } else if (e.key === "ArrowRight") {
                nextImage();
            } else if (e.key === "ArrowLeft") {
                prevImage();
            } else if (key === "l") {
                setTool("laser");
            } else if (key === "p") {
                setTool("pen");
            } else if (key === "c") {
                laserPointer.clearAll();
            }
        };

        window.removeEventListener("keydown", handleKeyDown);
        window.addEventListener("keydown", handleKeyDown);
    }

    initMapSystem();
    document.addEventListener("astro:page-load", initMapSystem);
</script>

<style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap");

    .concept-map-wrapper {
        position: relative;
        margin: 3rem 0;
    }

    .concept-map-container {
        background-color: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 16px;
        padding: 1.5rem 2rem;
        font-family: "Space Grotesk", sans-serif;
        color: #334155;
        position: relative;
        overflow: hidden;
    }

    .concept-map-container::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 4px;
        height: 100%;
        background: #2563eb;
    }

    .download-map-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        color: #64748b;
        font-family: inherit;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10;
    }

    .download-map-btn:hover {
        background: #f1f5f9;
        color: #2563eb;
        border-color: #cbd5e1;
        transform: translateY(-1px);
    }

    .download-map-btn.loading {
        opacity: 0.7;
        pointer-events: none;
    }

    .map-root {
        margin-bottom: 1rem;
    }

    .root-label {
        font-weight: 400;
        font-size: 1.3rem;
        color: #0f172a;
        letter-spacing: -0.02em;
    }

    .root-v-line {
        color: #cbd5e1;
        margin-left: 0.1rem;
        font-size: 0.9rem;
        margin-top: 0.2rem;
    }

    .map-branches {
        border-left: 1.5px solid #cbd5e1;
        margin-left: 0.5rem;
        padding-left: 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
        padding-top: 0.5rem;
    }
</style>
